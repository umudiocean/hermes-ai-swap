// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IPancakeRouter {
    function WETH() external pure returns (address);
    
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function getAmountsOut(uint amountIn, address[] calldata path)
        external view returns (uint[] memory amounts);
}

contract HermesBogSwap3 {
    // BSC Mainnet addresses
    address private constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private constant HERMES = 0x9495aB3549338BF14aD2F86CbcF79C7b574bba37;
    address private constant FEE_COLLECTOR = 0xd88026A648C95780e3056ed98eD60E5105cc4863;
    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;
    
    // Constants
    uint256 private constant PLATFORM_FEE = 0.0005 ether;
    uint256 private constant HERMES_REWARD = 100000 * 10**18;
    
    // State
    address private immutable owner;
    uint256 public totalSwaps;
    uint256 public totalRewardsDistributed;
    uint256 public totalFeesCollected;
    
    // Router
    IPancakeRouter private constant router = IPancakeRouter(PANCAKE_ROUTER);
    
    // Events
    event SwapExecuted(
        address indexed user,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 reward
    );
    event RewardPaid(address indexed user, uint256 amount);
    event FeeCollected(uint256 amount);
    event FeeTransferred(address to, uint256 amount);
    
    constructor() {
        owner = msg.sender;
    }
    
    receive() external payable {}
    
    // Main swap function with automatic fee transfer
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) external payable {
        require(msg.value >= PLATFORM_FEE, "Insufficient fee");
        require(tokenIn != tokenOut, "Same token");
        
        // Automatically transfer fee to FEE_COLLECTOR
        (bool feeSuccess,) = FEE_COLLECTOR.call{value: PLATFORM_FEE}("");
        require(feeSuccess, "Fee transfer failed");
        
        emit FeeCollected(PLATFORM_FEE);
        emit FeeTransferred(FEE_COLLECTOR, PLATFORM_FEE);
        totalFeesCollected += PLATFORM_FEE;
        
        uint256 amountOut;
        
        // Route based on token types
        if (tokenIn == address(0) || tokenIn == WBNB) {
            amountOut = _swapBNBForToken(tokenOut, msg.value - PLATFORM_FEE);
        } else if (tokenOut == address(0) || tokenOut == WBNB) {
            amountOut = _swapTokenForBNB(tokenIn, amountIn);
        } else {
            amountOut = _swapTokenForToken(tokenIn, tokenOut, amountIn);
        }
        
        // Update stats
        totalSwaps++;
        
        // Send reward
        uint256 rewardSent = _sendReward();
        
        emit SwapExecuted(msg.sender, tokenIn, tokenOut, amountIn, amountOut, rewardSent);
    }
    
    // BNB to Token swap
    function _swapBNBForToken(address tokenOut, uint256 bnbAmount) private returns (uint256) {
        require(bnbAmount > 0, "Invalid BNB amount");
        
        address[] memory path = _getPath(WBNB, tokenOut);
        uint256 balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);
        
        // Always use fee supporting swap
        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(
            0, // Accept any amount
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = IERC20(tokenOut).balanceOf(msg.sender);
        return balanceAfter - balanceBefore;
    }
    
    // Token to BNB swap - Critical for HERMES
    function _swapTokenForBNB(address tokenIn, uint256 amountIn) private returns (uint256) {
        require(amountIn > 0, "Invalid amount");
        
        // Transfer tokens from user
        require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn), "Transfer failed");
        
        // Get actual balance after fee
        uint256 actualBalance = IERC20(tokenIn).balanceOf(address(this));
        
        // Approve router
        IERC20(tokenIn).approve(PANCAKE_ROUTER, actualBalance);
        
        address[] memory path = _getPath(tokenIn, WBNB);
        uint256 balanceBefore = msg.sender.balance;
        
        // Execute swap with fee support
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            actualBalance,
            0, // Accept any amount
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = msg.sender.balance;
        return balanceAfter - balanceBefore;
    }
    
    // Token to Token swap
    function _swapTokenForToken(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) private returns (uint256) {
        require(amountIn > 0, "Invalid amount");
        
        // Transfer tokens from user
        require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn), "Transfer failed");
        
        // Get actual balance
        uint256 actualBalance = IERC20(tokenIn).balanceOf(address(this));
        
        // Approve router
        IERC20(tokenIn).approve(PANCAKE_ROUTER, actualBalance);
        
        address[] memory path = _getPath(tokenIn, tokenOut);
        uint256 balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);
        
        // Execute swap
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            actualBalance,
            0, // Accept any amount
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = IERC20(tokenOut).balanceOf(msg.sender);
        return balanceAfter - balanceBefore;
    }
    
    // Get optimal swap path
    function _getPath(address tokenIn, address tokenOut) private pure returns (address[] memory) {
        // Direct path for WBNB pairs
        if (tokenIn == WBNB || tokenOut == WBNB) {
            address[] memory directPath = new address[](2);
            directPath[0] = tokenIn;
            directPath[1] = tokenOut;
            return directPath;
        }
        
        // Route through WBNB for other pairs
        address[] memory indirectPath = new address[](3);
        indirectPath[0] = tokenIn;
        indirectPath[1] = WBNB;
        indirectPath[2] = tokenOut;
        return indirectPath;
    }
    
    // Send HERMES reward
    function _sendReward() private returns (uint256) {
        uint256 rewardBalance = IERC20(HERMES).balanceOf(address(this));
        if (rewardBalance >= HERMES_REWARD) {
            IERC20(HERMES).transfer(msg.sender, HERMES_REWARD);
            totalRewardsDistributed += HERMES_REWARD;
            emit RewardPaid(msg.sender, HERMES_REWARD);
            return HERMES_REWARD;
        }
        return 0;
    }
    
    // Convenience functions
    function swapBNBToHERMES() external payable {
        this.swap(address(0), HERMES, 0);
    }
    
    function swapHERMESToBNB(uint256 amount) external payable {
        this.swap(HERMES, address(0), amount);
    }
    
    // Estimate functions
    function estimateSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) external view returns (uint256 estimatedOut) {
        if (tokenIn == address(0)) tokenIn = WBNB;
        if (tokenOut == address(0)) tokenOut = WBNB;
        
        address[] memory path = _getPath(tokenIn, tokenOut);
        
        try router.getAmountsOut(amountIn, path) returns (uint[] memory amounts) {
            estimatedOut = amounts[amounts.length - 1];
            
            // Adjust for HERMES fee
            if (tokenIn == HERMES) {
                estimatedOut = estimatedOut * 97 / 100; // 3% fee
            }
            if (tokenOut == HERMES) {
                estimatedOut = estimatedOut * 97 / 100; // 3% fee on receive
            }
        } catch {
            estimatedOut = 0;
        }
    }
    
    // Admin functions
    function depositRewards(uint256 amount) external {
        require(IERC20(HERMES).transferFrom(msg.sender, address(this), amount), "Transfer failed");
    }
    
    // Emergency withdraw (only if automatic transfer fails)
    function emergencyWithdrawBNB() external {
        require(msg.sender == owner, "Not owner");
        uint256 balance = address(this).balance;
        require(balance > 0, "No BNB to withdraw");
        
        (bool success,) = owner.call{value: balance}("");
        require(success, "Withdrawal failed");
    }
    
    function withdrawToken(address token, uint256 amount) external {
        require(msg.sender == owner, "Not owner");
        require(token != address(0), "Invalid token");
        IERC20(token).transfer(owner, amount);
    }
    
    // View functions
    function getContractInfo() external view returns (
        uint256 hermesBalance,
        uint256 bnbBalance,
        uint256 swapCount,
        uint256 rewardsDistributed,
        uint256 feesCollected,
        bool canReward
    ) {
        hermesBalance = IERC20(HERMES).balanceOf(address(this));
        bnbBalance = address(this).balance;
        swapCount = totalSwaps;
        rewardsDistributed = totalRewardsDistributed;
        feesCollected = totalFeesCollected;
        canReward = hermesBalance >= HERMES_REWARD;
    }
    
    function getRewardBalance() external view returns (uint256) {
        return IERC20(HERMES).balanceOf(address(this));
    }
}