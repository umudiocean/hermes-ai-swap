// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IPancakeRouter02 {
    function swapExactETHForTokens(
        uint amountOutMin, 
        address[] calldata path, 
        address to, 
        uint deadline
    ) external payable returns (uint[] memory amounts);
    
    function WETH() external pure returns (address);
    
    function getAmountsOut(uint amountIn, address[] calldata path)
        external view returns (uint[] memory amounts);
}

contract HermesOptimizedRouter {
    // BSC Mainnet gerçek adresler
    address public constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address public constant HERMES_TOKEN = 0x9495aB3549338BF14aD2F86CbcF79C7b574bba37;
    address public constant FEE_COLLECTOR = 0xd88026A648C95780e3056ed98eD60E5105cc4863;
    
    // Sabit değerler
    uint256 public constant FEE_AMOUNT = 500000000000000; // 0.0005 BNB
    uint256 public constant HERMES_REWARD = 100000 * 10**18; // 100,000 HERMES (18 decimals)
    
    // Kullanıcı istatistikleri
    mapping(address => uint256) public userSwapCount;
    mapping(address => uint256) public totalRewardsEarned;
    
    // Debug state
    uint256 public lastErrorStep = 0;
    string public lastErrorMessage = "";
    
    // Events
    event SwapExecuted(
        address indexed user, 
        address indexed tokenOut, 
        uint256 bnbAmount, 
        uint256 tokenAmount, 
        uint256 hermesReward
    );
    
    event DebugInfo(
        string message,
        uint256 step,
        uint256 value,
        address addr
    );
    
    event ErrorLogged(
        uint256 step,
        string message,
        address user
    );
    
    receive() external payable {}
    
    /**
     * @dev Ana fonksiyon - Debug versiyonu
     */
    function swapExactETHForTokensWithHermesReward(
        uint256 amountOutMin,
        address tokenOut,
        address to,
        uint256 deadline
    ) external payable {
        
        // Step 1: Input validation
        if (msg.value <= FEE_AMOUNT) {
            lastErrorStep = 1;
            lastErrorMessage = "Insufficient BNB amount";
            emit ErrorLogged(1, "Insufficient BNB amount", msg.sender);
            revert("Insufficient BNB amount");
        }
        
        if (tokenOut == address(0) || to == address(0)) {
            lastErrorStep = 2;
            lastErrorMessage = "Invalid address";
            emit ErrorLogged(2, "Invalid address", msg.sender);
            revert("Invalid address");
        }
        
        if (deadline < block.timestamp) {
            lastErrorStep = 3;
            lastErrorMessage = "Deadline expired";
            emit ErrorLogged(3, "Deadline expired", msg.sender);
            revert("Deadline expired");
        }
        
        emit DebugInfo("Input validation passed", 1, msg.value, msg.sender);
        
        // Step 2: Hermes balance check
        uint256 hermesBalance = IERC20(HERMES_TOKEN).balanceOf(address(this));
        if (hermesBalance < HERMES_REWARD) {
            lastErrorStep = 4;
            lastErrorMessage = "Insufficient Hermes balance";
            emit ErrorLogged(4, "Insufficient Hermes balance", msg.sender);
            emit DebugInfo("Hermes balance insufficient", 2, hermesBalance, HERMES_TOKEN);
            revert("Insufficient Hermes balance");
        }
        
        emit DebugInfo("Hermes balance OK", 2, hermesBalance, HERMES_TOKEN);
        
        uint256 swapAmount = msg.value - FEE_AMOUNT;
        
        // Step 3: Fee transfer
        (bool feeSuccess,) = FEE_COLLECTOR.call{value: FEE_AMOUNT}("");
        if (!feeSuccess) {
            lastErrorStep = 5;
            lastErrorMessage = "Fee transfer failed";
            emit ErrorLogged(5, "Fee transfer failed", msg.sender);
            revert("Fee transfer failed");
        }
        
        emit DebugInfo("Fee sent successfully", 3, FEE_AMOUNT, FEE_COLLECTOR);
        
        // Step 4: Prepare swap path
        address[] memory path = new address[](2);
        path[0] = WBNB;
        path[1] = tokenOut;
        
        emit DebugInfo("Path prepared", 4, swapAmount, tokenOut);
        
        // Step 5: Execute swap
        uint256[] memory amounts;
        try IPancakeRouter02(PANCAKE_ROUTER).swapExactETHForTokens{value: swapAmount}(
            amountOutMin,
            path,
            to,
            deadline
        ) returns (uint256[] memory _amounts) {
            amounts = _amounts;
            emit DebugInfo("Swap successful", 5, amounts[0], tokenOut);
        } catch Error(string memory reason) {
            lastErrorStep = 6;
            lastErrorMessage = reason;
            emit ErrorLogged(6, reason, msg.sender);
            revert(reason);
        } catch (bytes memory) {
            lastErrorStep = 7;
            lastErrorMessage = "Swap failed - unknown reason";
            emit ErrorLogged(7, "Swap failed - unknown reason", msg.sender);
            revert("Swap failed - unknown reason");
        }
        
        // Step 6: Send Hermes reward
        try IERC20(HERMES_TOKEN).transfer(to, HERMES_REWARD) returns (bool success) {
            if (!success) {
                lastErrorStep = 8;
                lastErrorMessage = "Hermes transfer returned false";
                emit ErrorLogged(8, "Hermes transfer returned false", msg.sender);
                revert("Hermes transfer returned false");
            }
            emit DebugInfo("Hermes reward sent", 6, HERMES_REWARD, to);
        } catch Error(string memory reason) {
            lastErrorStep = 9;
            lastErrorMessage = reason;
            emit ErrorLogged(9, reason, msg.sender);
            revert(reason);
        } catch (bytes memory) {
            lastErrorStep = 10;
            lastErrorMessage = "Hermes transfer failed - unknown";
            emit ErrorLogged(10, "Hermes transfer failed - unknown", msg.sender);
            revert("Hermes transfer failed");
        }
        
        // Step 7: Update stats
        userSwapCount[to]++;
        totalRewardsEarned[to] += HERMES_REWARD;
        
        emit SwapExecuted(to, tokenOut, swapAmount, amounts[1], HERMES_REWARD);
        emit DebugInfo("Swap completed successfully", 7, userSwapCount[to], to);
        
        // Reset error state on success
        lastErrorStep = 0;
        lastErrorMessage = "";
    }
    
    /**
     * @dev Kontrat sağlık durumunu kontrol eder
     */
    function healthCheck() external view returns (
        bool isHealthy,
        uint256 contractBNB,
        uint256 contractHermes,
        bool canReward,
        uint256 lastError,
        string memory lastMsg
    ) {
        uint256 bnbBalance = address(this).balance;
        uint256 hermesBalance = IERC20(HERMES_TOKEN).balanceOf(address(this));
        bool canGiveReward = hermesBalance >= HERMES_REWARD;
        
        return (canGiveReward, bnbBalance, hermesBalance, canGiveReward, lastErrorStep, lastErrorMessage);
    }
    
    /**
     * @dev Kullanıcının toplam swap sayısını döndürür
     */
    function getUserSwapCount(address user) external view returns (uint256) {
        return userSwapCount[user];
    }
    
    /**
     * @dev Kullanıcının toplam kazandığı Hermes miktarını döndürür  
     */
    function getTotalRewardsEarned(address user) external view returns (uint256) {
        return totalRewardsEarned[user];
    }
    
    /**
     * @dev Kontratın Hermes token bakiyesini döndürür
     */
    function getContractHermesBalance() external view returns (uint256) {
        return IERC20(HERMES_TOKEN).balanceOf(address(this));
    }
    
    /**
     * @dev Kontratın BNB bakiyesini döndürür
     */
    function getContractBNBBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    /**
     * @dev Tahmini çıkış token miktarını hesaplar
     */
    function getEstimatedTokenOut(uint256 bnbAmount, address tokenOut) 
        external view returns (uint256) {
        if (bnbAmount <= FEE_AMOUNT) return 0;
        
        uint256 swapAmount = bnbAmount - FEE_AMOUNT;
        address[] memory path = new address[](2);
        path[0] = WBNB;
        path[1] = tokenOut;
        
        try IPancakeRouter02(PANCAKE_ROUTER).getAmountsOut(swapAmount, path) 
            returns (uint256[] memory amounts) {
            return amounts[1];
        } catch {
            return 0;
        }
    }
    
    /**
     * @dev Sadece test için - basit swap
     */
    function testSwap() external payable {
        require(msg.value >= 0.001 ether, "Send at least 0.001 BNB");
        
        emit DebugInfo("Test swap called", 0, msg.value, msg.sender);
        
        // Basit test - fee al ve kalan geri gönder
        uint256 feeAmount = msg.value / 10; // %10 fee
        (bool success,) = FEE_COLLECTOR.call{value: feeAmount}("");
        require(success, "Fee transfer failed");
        
        // Kalan miktarı geri gönder
        uint256 remaining = msg.value - feeAmount;
        (bool returnSuccess,) = msg.sender.call{value: remaining}("");
        require(returnSuccess, "Return failed");
        
        emit DebugInfo("Test swap completed", 0, feeAmount, msg.sender);
    }
    
    // =================== EMERGENCY FUNCTIONS ===================
    
    /**
     * @dev Acil durum BNB çekme (sadece fee collector)
     */
    function emergencyWithdrawBNB() external {
        require(msg.sender == FEE_COLLECTOR, "Only fee collector");
        
        uint256 balance = address(this).balance;
        (bool success,) = FEE_COLLECTOR.call{value: balance}("");
        require(success, "BNB withdrawal failed");
    }
    
    /**
     * @dev Acil durum token çekme (sadece fee collector)
     */
    function emergencyWithdrawTokens(address token) external {
        require(msg.sender == FEE_COLLECTOR, "Only fee collector");
        require(token != address(0), "Invalid address");
        
        uint256 balance = IERC20(token).balanceOf(address(this));
        bool success = IERC20(token).transfer(FEE_COLLECTOR, balance);
        require(success, "Token withdrawal failed");
    }
    
    /**
     * @dev Kontrat bilgilerini döndürür
     */
    function getContractInfo() external pure returns (
        address router,
        address wbnb, 
        address hermesToken,
        address feeCollector,
        uint256 feeAmount,
        uint256 hermesReward
    ) {
        return (
            PANCAKE_ROUTER,
            WBNB,
            HERMES_TOKEN, 
            FEE_COLLECTOR,
            FEE_AMOUNT,
            HERMES_REWARD
        );
    }
}