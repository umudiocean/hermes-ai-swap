// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function decimals() external view returns (uint8);
}

interface IPancakeRouter {
    function WETH() external pure returns (address);
    
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function getAmountsOut(uint amountIn, address[] calldata path)
        external view returns (uint[] memory amounts);
}

contract HermesBogSwap3 {
    // BSC Mainnet addresses
    address private constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private constant HERMES = 0x9495aB3549338BF14aD2F86CbcF79C7b574bba37;
    address private constant FEE_COLLECTOR = 0xd88026A648C95780e3056ed98eD60E5105cc4863;
    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;
    
    // Constants
    uint256 private constant PLATFORM_FEE = 0.0005 ether;
    uint256 private constant HERMES_REWARD = 100000 * 10**18;
    uint256 private constant HERMES_USER_REWARD = 90000 * 10**18;  // Referans ile
    uint256 private constant HERMES_REFERRAL_REWARD = 10000 * 10**18;  // Referans sahibine
    
    // State
    address private immutable owner;
    uint256 public totalSwaps;
    uint256 public totalRewardsDistributed;
    uint256 public totalFeesCollected;
    uint256 public totalReferralRewards;
    
    // Referral System
    mapping(address => uint256) public referralCodes;
    mapping(uint256 => address) public codeToReferrer;
    mapping(address => uint256) public referralEarnings;
    mapping(address => uint256) public totalReferrals;
    uint256 private nextReferralCode = 1000;
    
    // Router
    IPancakeRouter private constant router = IPancakeRouter(PANCAKE_ROUTER);
    
    // Events
    event SwapExecuted(
        address indexed user,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 userReward,
        uint256 referralReward,
        address referrer
    );
    event RewardPaid(address indexed user, uint256 amount);
    event ReferralRewardPaid(address indexed referrer, address indexed user, uint256 amount);
    event FeeCollected(uint256 amount);
    event FeeTransferred(address to, uint256 amount);
    event ReferralCodeGenerated(address indexed user, uint256 code);
    
    constructor() {
        owner = msg.sender;
    }
    
    receive() external payable {}
    
    // Generate referral code for user
    function generateReferralCode() external returns (uint256) {
        require(referralCodes[msg.sender] == 0, "Code already exists");
        
        uint256 code = nextReferralCode;
        nextReferralCode++;
        
        referralCodes[msg.sender] = code;
        codeToReferrer[code] = msg.sender;
        
        emit ReferralCodeGenerated(msg.sender, code);
        return code;
    }
    
    // Main swap function with referral system
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 referralCode
    ) external payable {
        require(msg.value >= PLATFORM_FEE, "Insufficient fee");
        require(tokenIn != tokenOut, "Same token");
        
        // Automatically transfer fee to FEE_COLLECTOR
        (bool feeSuccess,) = FEE_COLLECTOR.call{value: PLATFORM_FEE}("");
        require(feeSuccess, "Fee transfer failed");
        
        emit FeeCollected(PLATFORM_FEE);
        emit FeeTransferred(FEE_COLLECTOR, PLATFORM_FEE);
        totalFeesCollected += PLATFORM_FEE;
        
        uint256 amountOut;
        
        // Route based on token types
        if (tokenIn == address(0) || tokenIn == WBNB) {
            amountOut = _swapBNBForToken(tokenOut, msg.value - PLATFORM_FEE);
        } else if (tokenOut == address(0) || tokenOut == WBNB) {
            amountOut = _swapTokenForBNB(tokenIn, amountIn);
        } else {
            amountOut = _swapTokenForToken(tokenIn, tokenOut, amountIn);
        }
        
        // Update stats
        totalSwaps++;
        
        // Process referral rewards
        address referrer = address(0);
        uint256 userReward = 0;
        uint256 referralReward = 0;
        
        if (referralCode > 0 && codeToReferrer[referralCode] != address(0) && codeToReferrer[referralCode] != msg.sender) {
            // Referral kullanıldı
            referrer = codeToReferrer[referralCode];
            (userReward, referralReward) = _sendReferralRewards(referrer);
        } else {
            // Referral yok, tam ödül
            userReward = _sendFullReward();
        }
        
        emit SwapExecuted(msg.sender, tokenIn, tokenOut, amountIn, amountOut, userReward, referralReward, referrer);
    }
    
    // Referral ile ödül gönder
    function _sendReferralRewards(address referrer) private returns (uint256 userReward, uint256 referralReward) {
        uint256 hermesBalance = IERC20(HERMES).balanceOf(address(this));
        
        if (hermesBalance >= HERMES_REWARD) {
            // Kullanıcıya 90,000 HERMES
            IERC20(HERMES).transfer(msg.sender, HERMES_USER_REWARD);
            userReward = HERMES_USER_REWARD;
            
            // Referans sahibine 10,000 HERMES
            IERC20(HERMES).transfer(referrer, HERMES_REFERRAL_REWARD);
            referralReward = HERMES_REFERRAL_REWARD;
            
            // İstatistikleri güncelle
            totalRewardsDistributed += HERMES_REWARD;
            totalReferralRewards += HERMES_REFERRAL_REWARD;
            referralEarnings[referrer] += HERMES_REFERRAL_REWARD;
            totalReferrals[referrer]++;
            
            emit RewardPaid(msg.sender, HERMES_USER_REWARD);
            emit ReferralRewardPaid(referrer, msg.sender, HERMES_REFERRAL_REWARD);
        }
        
        return (userReward, referralReward);
    }
    
    // Tam ödül gönder (referral yok)
    function _sendFullReward() private returns (uint256) {
        uint256 hermesBalance = IERC20(HERMES).balanceOf(address(this));
        
        if (hermesBalance >= HERMES_REWARD) {
            IERC20(HERMES).transfer(msg.sender, HERMES_REWARD);
            totalRewardsDistributed += HERMES_REWARD;
            emit RewardPaid(msg.sender, HERMES_REWARD);
            return HERMES_REWARD;
        }
        
        return 0;
    }
    
    // BNB to Token swap
    function _swapBNBForToken(address tokenOut, uint256 bnbAmount) private returns (uint256) {
        require(bnbAmount > 0, "Invalid BNB amount");
        
        address[] memory path = _getPath(WBNB, tokenOut);
        uint256 balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);
        
        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(
            0,
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = IERC20(tokenOut).balanceOf(msg.sender);
        return balanceAfter - balanceBefore;
    }
    
    // Token to BNB swap
    function _swapTokenForBNB(address tokenIn, uint256 amountIn) private returns (uint256) {
        require(amountIn > 0, "Invalid amount");
        
        require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn), "Transfer failed");
        uint256 actualBalance = IERC20(tokenIn).balanceOf(address(this));
        
        IERC20(tokenIn).approve(PANCAKE_ROUTER, actualBalance);
        
        address[] memory path = _getPath(tokenIn, WBNB);
        uint256 balanceBefore = msg.sender.balance;
        
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            actualBalance,
            0,
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = msg.sender.balance;
        return balanceAfter - balanceBefore;
    }
    
    // Token to Token swap
    function _swapTokenForToken(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) private returns (uint256) {
        require(amountIn > 0, "Invalid amount");
        
        require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn), "Transfer failed");
        uint256 actualBalance = IERC20(tokenIn).balanceOf(address(this));
        
        IERC20(tokenIn).approve(PANCAKE_ROUTER, actualBalance);
        
        address[] memory path = _getPath(tokenIn, tokenOut);
        uint256 balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);
        
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            actualBalance,
            0,
            path,
            msg.sender,
            block.timestamp + 300
        );
        
        uint256 balanceAfter = IERC20(tokenOut).balanceOf(msg.sender);
        return balanceAfter - balanceBefore;
    }
    
    // Get optimal swap path
    function _getPath(address tokenIn, address tokenOut) private pure returns (address[] memory) {
        if (tokenIn == WBNB || tokenOut == WBNB) {
            address[] memory directPath = new address[](2);
            directPath[0] = tokenIn;
            directPath[1] = tokenOut;
            return directPath;
        }
        
        address[] memory indirectPath = new address[](3);
        indirectPath[0] = tokenIn;
        indirectPath[1] = WBNB;
        indirectPath[2] = tokenOut;
        return indirectPath;
    }
    
    // Convenience functions
    function swapBNBToHERMES(uint256 referralCode) external payable {
        this.swap(address(0), HERMES, 0, referralCode);
    }
    
    function swapHERMESToBNB(uint256 amount, uint256 referralCode) external payable {
        this.swap(HERMES, address(0), amount, referralCode);
    }
    
    // Estimate functions
    function estimateSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) external view returns (uint256 estimatedOut) {
        if (tokenIn == address(0)) tokenIn = WBNB;
        if (tokenOut == address(0)) tokenOut = WBNB;
        
        address[] memory path = _getPath(tokenIn, tokenOut);
        
        try router.getAmountsOut(amountIn, path) returns (uint[] memory amounts) {
            estimatedOut = amounts[amounts.length - 1];
            
            if (tokenIn == HERMES) {
                estimatedOut = estimatedOut * 97 / 100;
            }
            if (tokenOut == HERMES) {
                estimatedOut = estimatedOut * 97 / 100;
            }
        } catch {
            estimatedOut = 0;
        }
    }
    
    // Referral view functions
    function getReferralCode(address user) external view returns (uint256) {
        return referralCodes[user];
    }
    
    function getReferrerByCode(uint256 code) external view returns (address) {
        return codeToReferrer[code];
    }
    
    function getReferralStats(address user) external view returns (
        uint256 code,
        uint256 earnings,
        uint256 totalRefs,
        bool hasCode
    ) {
        code = referralCodes[user];
        earnings = referralEarnings[user];
        totalRefs = totalReferrals[user];
        hasCode = code > 0;
    }
    
    // Admin functions
    function depositRewards(uint256 amount) external {
        require(IERC20(HERMES).transferFrom(msg.sender, address(this), amount), "Transfer failed");
    }
    
    function emergencyWithdrawBNB() external {
        require(msg.sender == owner, "Not owner");
        uint256 balance = address(this).balance;
        require(balance > 0, "No BNB to withdraw");
        
        (bool success,) = owner.call{value: balance}("");
        require(success, "Withdrawal failed");
    }
    
    function withdrawToken(address token, uint256 amount) external {
        require(msg.sender == owner, "Not owner");
        require(token != address(0), "Invalid token");
        IERC20(token).transfer(owner, amount);
    }
    
    // View functions
    function getContractInfo() external view returns (
        uint256 hermesBalance,
        uint256 bnbBalance,
        uint256 swapCount,
        uint256 rewardsDistributed,
        uint256 feesCollected,
        uint256 referralRewardsTotal,
        bool canReward
    ) {
        hermesBalance = IERC20(HERMES).balanceOf(address(this));
        bnbBalance = address(this).balance;
        swapCount = totalSwaps;
        rewardsDistributed = totalRewardsDistributed;
        feesCollected = totalFeesCollected;
        referralRewardsTotal = totalReferralRewards;
        canReward = hermesBalance >= HERMES_REWARD;
    }
    
    function getRewardBalance() external view returns (uint256) {
        return IERC20(HERMES).balanceOf(address(this));
    }
}